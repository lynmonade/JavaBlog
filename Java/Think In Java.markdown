# Think In Java读书笔记



## 第1章《对象导论》
这一章值得我们读很多遍，他讲解了从面向过程到面向对象变量的由来，讲解了“类”背后的思想，讲解了继承与组合，讲解了对象的创建与销毁，GC的作用等等一大堆东西，这一章读10遍都不为过。

## 第2章《一切都是对象》 完成
### 2.1 用引用操纵对象
这一章提出了一个很有趣的理解方式，对象就是电视机，而对象的引用是遥控器，当你想调大电视机音量时，你实际上只需要操控遥控器即可。当你想在房间里走来走去，并操控电视机时，你只需要携带遥控器即可，而不必抱着电视机。

没有电视机，遥控器也可以存在。也就是一个引用没有关联任何对象，这是不安全的做法，最好的做法是，在创建一个引用时就立刻进行初始化。

### 2.2 必须由你创建所有对象
这一节说明了java变量具体存储在哪：

* 寄存器：这是最快的存储区，它位于处理器内部。寄存器的数量和空间极其有限，所以寄存器根据需求进行分配，不能直接控制，使用java时你根本感觉不到寄存器的存在。
* 堆栈/栈：位于RAM中，通过把指针下移huo分配新的内存，指针上移释放内存。这是一种非常快速有效的分配和释放内存的方式，仅次于寄存器。但java系统必须知道存储在堆栈内所有项确切的生命周期。以便上下移动指针。这一约束限制了程序的灵活性，java把引用存在栈中，但对象并不存在栈中。（用灵活性换区时间，即灵活性下降，但时间更优）
* 堆：一种通用的内存池，也位于RAM中。用于存放所有的java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间，因此在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码。但这种灵活性是要付出代价的：用堆进行存储分配和清理可能比堆栈进行存储分配需要更多的时间。（用时间换灵活性，即灵活性提升，但时间较差）
* 常量存储：常量值直接存储在程序代码内部，这么做是安全的，因为他们永远不会改变。在嵌入式系统中，也可以把常量放在ROM（只读存储器中）。比如一个常见的例子就是字符串池，所有字面常量字符串和具有字符串值的常量表达式都自动是内存限定的，并且会置于特殊的静态存储区中。
* 非RAM存储：如果数据完全存活于程序之外，不受程序的任何限制，在程序没有运行时也可以存在。常见例子就是流对象和持久化对象。

此外，这一章还提到了java的基本类型的大小，对应的包装类，以及BigInteger、BigDecimal类。还提到了，BigXXX类所提供的操作与基本类型比如int、float的操作很类似，BigXXX的精度更高，但速度较慢，是一种速度换精度的方式。

还提到了数组，java对数组做了很多基本的检查，虽然开销稍微增大了，但可以在编译期有效的检查出许多错误。所以程序员使用java的数组时比较安心。

###2.3 至 2.10 
成员变量默认值：

![成员变量默认值](http://wx2.sinaimg.cn/mw690/0065Y1avgy1fd3z1ybc29j306w057q35.jpg)

方法的调用也称为发送消息给对象。当方法参数是对象时，我们实际上传的是对象的引用（传的是遥控器），而不是对象本身（我们不需要抱着电视机走来走去！）。

static修饰成员变量和局部变量时，它表示这个成员变量/局部变量只有一份，而不会为每个对象都创建一份！static变量在程序启动时就创建，在程序关闭时才被自动销毁。

最后还讲了一些关于生成注释doc文档的方法。



## 第4章 《控制执行流程》

**臭名昭著的goto值得读一下。**

switch也值得重新学习。

## 第5章 初始化与清理 完成

**初始化与清理**本质上是关于**安全编程**。即如何让程序员规范的创建并初始化一个对象，如何让程序员规范的销毁一个对象。初始化的清理是系统需求，而非业务需求。一般来说，创建和初始化是两个步骤，但在java中把他们合二为一了，因为这可以保证创建出来的对象是有初始值的，是可以安全使用的。

方法重载由方法参数决定，包括方法参数类型，以及方法参数顺序。方法返回值不作为重载标志。

当重载方法接受基本类型的参数，如果形参是宽类型，而实参是窄类型，则无需强制类型转换，程序会自动选择合适的重载方法；如果形参是窄类型，而实参是宽类型，则需要手工进行类型转换。此外还有一些特殊情况。**面对这么复杂的情况，我建议，还是老老实实用最土的方法，当形参和实参类型不必配时，显式地进行类型转换最稳妥。**

对象调用方法时，编译器会偷偷的帮我们把对象的引用作为参数传入方法中，因此我们才能在方法中使用this关键字。方法中的this关键字表示调用该方法的对象。

```java
People p = new People();
p.eat(String fruit);
//等价于
p.eat(String fruit, People p);
```

此外，this还能在重载的构造函数中使用，这样的编程习惯是有好处的，对外提供N个secondary构造函数，而内部实际上转调唯一一个构造函数。

static方法就是没有this的方法，static方法内部不能调用非static方法，但反过来可以。我们一般用类名来访问static方法，static方法内部也可以方法static成员变量。

《5.5 清理：终结处理处理和垃圾回收》值得多读几遍。

编译器会帮成员变量自动初始化，但不会帮局部变量初始化。我们也可以使用一个方法来对成员变量进行初始化`Object o = f();`。即使我们使用了构造函数来初始化成员变量，但编译器还是会在我们调用构造函数之前就先初始化成员变量一次，然后在调用构造函数。这样的做法可以最稳妥的保证成员变量**一定会被初始化**。

static在修饰变量时，只能修饰成员变量，不能修饰局部变量。当第一次调用MyClass.sataicMember或者调用new MyClass()时，static成员变量才会被初始化，并且仅调用一次。如果没有显式地给static成员变量初始化，则编译器会自动帮它初始化，就像普通的成员变量一样。

此外，static代码块也是像static成员变量一样，在第一次调用MyClass.sataicMember或者调用new MyClass()时将被调用，并且仅调用一次。以后在创建对象也不会在调用了。

java也支持非静态实例初始化，这在匿名内部类中比较有用。这种类型的成员变量会在构造函数之前被初始化。

```java
public class Mugs {
	String s1;
	String s2;
	{
		s1 = new String("a"); //先调用
		s2 = "b"; //先调用
	}
	public Mugs() {
		System.out.println("constructor Mugs"); //后调用
	}
}
```



![](http://wx3.sinaimg.cn/mw690/0065Y1avgy1fd8jko78vxj30o709ldk0.jpg)



可变参数本质上就是数组，因此我们可以用for-each语法来遍历他们。此外，可变参数也可以不传参数。如果有必要的话，编译器也会自动对基本类型的形参进行包装，形成包装类，以适应包装类型的可变形参。最后还要特别注意可变参数的重载问题。

枚举类型是语法糖，没有枚举你也能编写程序，但枚举能让你的程序更优雅。有时间再研究吧。

##  第6章《访问权限控制》 完成

java访问权限有四种：public、protected、private、包访问权限（没有关键字）。每个.java文件都是一个编译单元。一个编译单元只能有一个public的类，并且这个类必须与编译单元文件同名。如果编译单元还有其他的类，那么他们在包之外是无法被访问的，因为他们不是public类，他们主要是用来为public类提供支持。

在同一个包下，不同类之间可以访问对方的public、protected、无修饰符的成员变量和方法。

在不同的包下，不同类之间只能访问对方额public成员变量和方法。

protected实质上表示**继承访问权限**

**无修饰符表示包访问权限**，即同一个包下的类可以互相访问对方的**报访问权限方法和成员变量**。

我们只能使用public、或者包访问权限（无关键字）修饰类。不能用protected或private。

一般来说，我们遵循最小权限访问控制的原则就没问题了。

## 第7章 复用类

复用类的三种方式：

1. 组合就是把原有类作为成员变量放到新创建类的中。

2. 继承就是新的类extends原有类。这样就自动获得了原有类的能力。

3. 代理，就是让新类持有原有类的引用，并且新类还将暴露出和原有类一样的方法来。（暴露通过interface接口来约定，即新类、原有类实现同样的接口）

   @Override表示你告诉编译器：你要复写基类的一个完全相同的方法（同名、同参数、同返回值）。此时如果在基类没有找到这样完全相同的方法，则其实是发生重载，即你在子类中定义了一个方法名相同但参数不同的方法。这并不是你想要的，编译器会在编译时就给你报错了。因此@Override注解有助于提醒你：“你需要使用的是重写，而不是重载！请检查你的函数定义！”。

   ### 继承与组合的选择

   组合是has a的关系，有一个。组合常用语想在新类中使用现有类的功能而非塔的接口（无需暴露现有类的方法）。客户端程序员看到的只是新类的方法，看不到原有类的方法。此外，我们也尽量把现有类声明为private。

   继承是is a的关系，是一个。继承是使用某个现有类，并开发一个它的特殊版本。这意味着你在使用一个通用的类，并为了某种特殊需要而将其特殊化。

   如果你需要向上类型转换，则可以使用继承，否则请使用组合。

   **final的介绍，多读几遍**
## 第8章 多态

1. 多态不会覆盖私有方法：final修饰的方法使用的是前期绑定，即在编译期就确定了。如果在基类定义private final方法，则在子类是无法被覆盖的。因此基类的private final方法最好使用一些特殊的名字。
2. 在多态中，基类和子类的成员变量和静态方法也是前期绑定的，如果基类和子类有同样名称的成员变量，则子类将有两个成员变量：sub.field, super.field。而静态方法与类绑定，而不是与单个对象绑定。
3. java中，除了static方法、final方法、private方法、构造函数之外，其他函数都是多态的。

在继承与多态中，如果需要创建子类，则会顺着继承链，先创建顶端的基类，然后顺着下来创建其他类。即现有爸爸，再有儿子。而在销毁对象时，则先销毁子类，再销毁基类，因为子类在销毁时可能会调用基类的某些销毁函数，因此不能过早的销毁基类。
在构造函数中，最好不要调用其他函数，而只做一些简单成员变量初始化操作，让对象尽量进入正常状态。如果真的要调用，则只能调用private或final方法。

## 第9章 接口 完成
抽象方法：`abstract void f();`

包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，则这个类也必须是抽象的。

```java
public abstract class MyClass {
    public abstract void f();
}
```

我们无法实例化抽象类，我们只能做两件事：

1. 继承抽象类，并实现所有抽象方法
2. 集成抽象类，但不实现所有抽象方法，这是这个类也必须声明为抽象类

接口使用interface关键字定义，一个接口表示：**所有实现了该特定接口的类看起来都像这样。因此使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需要知道这些。因此，接口被用来建立类与类之间的协议。**

接口interface关键之前可以使用public关键字，表示对对所有文件可见。如果不加public，则该接口只具有包访问权限。

接口可以包含成员变量，但这些成员变量都会自动被设置为static和final类型的。

9.3、9.6小节还提到了适配器模式，只要记住**使用extends把现有能力继承过来，使用implements来适配新的接口。**

接口在适配器模式、策略模式、工厂模式中应用非常广泛。

接口也可以嵌套在其他类或其他接口中，但这并没啥用。

## 已形成博客的章节

* 第11章 持有对象
* 第16章 数组