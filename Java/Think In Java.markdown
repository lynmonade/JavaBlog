# Think In Java读书笔记
## 第1章《对象导论》
这一章值得我们读很多遍，他讲解了从面向过程到面向对象变量的由来，讲解了“类”背后的思想，讲解了继承与组合，讲解了对象的创建与销毁，GC的作用等等一大堆东西，这一章读10遍都不为过。

## 第2章《一切都是对象》
### 2.1 用引用操纵对象
这一章提出了一个很有趣的理解方式，对象就是电视机，而对象的引用是遥控器，当你想调大电视机音量时，你实际上只需要操控遥控器即可。当你想在房间里走来走去，并操控电视机时，你只需要携带遥控器即可，而不必抱着电视机。

没有电视机，遥控器也可以存在。也就是一个引用没有关联任何对象，这是不安全的做法，最好的做法是，在创建一个引用时就立刻进行初始化。

### 2.2 必须由你创建所有对象
这一节说明了java变量具体存储在哪：

* 寄存器：这是最快的存储区，它位于处理器内部。寄存器的数量和空间极其有限，所以寄存器根据需求进行分配，不能直接控制，使用java时你根本感觉不到寄存器的存在。
* 堆栈/栈：位于RAM中，通过把指针下移huo分配新的内存，指针上移释放内存。这是一种非常快速有效的分配和释放内存的方式，仅次于寄存器。但java系统必须知道存储在堆栈内所有项确切的生命周期。以便上下移动指针。这一约束限制了程序的灵活性，java把引用存在栈中，但对象并不存在栈中。（用灵活性换区时间，即灵活性下降，但时间更优）
* 堆：一种通用的内存池，也位于RAM中。用于存放所有的java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间，因此在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码。但这种灵活性是要付出代价的：用堆进行存储分配和清理可能比堆栈进行存储分配需要更多的时间。（用时间换灵活性，即灵活性提升，但时间较差）
* 常量存储：常量值直接存储在程序代码内部，这么做是安全的，因为他们永远不会改变。在嵌入式系统中，也可以把常量放在ROM（只读存储器中）。比如一个常见的例子就是字符串池，所有字面常量字符串和具有字符串值的常量表达式都自动是内存限定的，并且会置于特殊的静态存储区中。
* 非RAM存储：如果数据完全存活于程序之外，不受程序的任何限制，在程序没有运行时也可以存在。常见例子就是流对象和持久化对象。

此外，这一章还提到了java的基本类型的大小，对应的包装类，以及BigInteger、BigDecimal类。还提到了，BigXXX类所提供的操作与基本类型比如int、float的操作很类似，BigXXX的精度更高，但速度较慢，是一种速度换精度的方式。

还提到了数组，java对数组做了很多基本的检查，虽然开销稍微增大了，但可以在编译期有效的检查出许多错误。所以程序员使用java的数组时比较安心。

###2.3 至 2.10 
成员变量默认值：

![成员变量默认值](http://wx2.sinaimg.cn/mw690/0065Y1avgy1fd3z1ybc29j306w057q35.jpg)

方法的调用也称为发送消息给对象。当方法参数是对象时，我们实际上传的是对象的引用（传的是遥控器），而不是对象本身（我们不需要抱着电视机走来走去！）。

static修饰成员变量和局部变量时，它表示这个成员变量/局部变量只有一份，而不会为每个对象都创建一份！static变量在程序启动时就创建，在程序关闭时才被自动销毁。

最后还讲了一些关于生成注释doc文档的方法。



## 第11章 《持有对象》

### 11.1

有可能的话，尽量会用接口类型变量来持有容器对象，这样未来可以更方便的进行替换。

### 11.2

容器可以大致分为两类：

1. Collection：一个独立元素的序列。LIst、Set、Queue属于这一类。List必须按照插入的顺序保持元素。Set不能有重复元素。Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）
2. Map：一组成对的”键值对“对象，允许你使用键来查找值。ArrayList允许你使用数字来查找值，因此可以说它将数字与对象关联在了一起。而Map则使用两一个对象来查找某个对象。

### 11.3

Collections类和Arrays类提供了许多static方法，方便我们操纵Collection和数组。

Arrays.asList()方法返回的是一个定长list，因此我们不能修改这个list的长度，不能对其调用add，remove方法。另外，书中还推荐像下面一样使用asList()方法：



```java
class Snow{}
class Power extends Snow{}
class Light extends Power{}
class Heavy extends Power{}
class Crusty extends Snow{}
class Slush extends Snow{}
public class Test2 {
	public static void main(String[] args) {
		//ok
		List<Snow> snow1 = Arrays.asList(new Power(), new Crusty(), new Slush());
		
		//在JDK6会报错,JDK8编译通过
		List<Snow> snow2 = Arrays.asList(new Light(), new Heavy()); 
		
		//ok
		List<Snow> snow3 = new ArrayList<Snow>();
		Collections.addAll(snow3, new Light(), new Heavy());
		
		//ok，推荐做法
		List<Snow> snow4 = Arrays.<Snow>asList(new Light(), new Heavy());
	}
}
```

###  11.4 容器的打印

Collection和Map都重写toString()方法，因此可以格式化打印其中的元素。



### 11.5 List

讲了list的基本API使用。



### 11.6 迭代器

迭代器的几个重要方法。Iterator的真正威力在于，能够将遍历序列的操作与序列底层的结构分离。正由于此，我们会说，迭代器统一了对容器的访问方式。

* iterator()获取迭代器
* next()获得下一个元素
* hasNext()检查序列中是否还有元素
* remove()将迭代器新近返回的元素删除

ListIterator是Iterator的子类，只能用于List类的遍历，提供了更强大的API方法。



## 第16章《数组》

这张比较简单，除了多维数组没看，其他都看了