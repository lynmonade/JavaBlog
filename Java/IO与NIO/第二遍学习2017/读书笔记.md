# File常用例子

## 获取当前路径

```java
File file1 = new File(""); //AbsolutePath=D:\workspace\eclipse4x\io3 在java项目中任意位置执行这一句
File file2 = new File("/"); //AbsolutePath=D:\ 获取项目所在根路径，windows的根路径是盘符
```

## 获取上一级路径

```java
File file1 = new File(""); 
//别用getAbsolutePath()，因为file1有可能是相对路径
String parent = file1.getAbsoluteFile().getParent(); // D:\workspace\eclipse4x
```

## 遍历子文件

```java
File file = new File("");
String[] subFileNames = file.list();
```

## 过滤子文件

使用FilenameFilter接口，结合Command设计模式即可实现。本质上我们是在遍历的过程中，传入一个过滤策略。

```java
public class Client {
	public static void main(String[] args) {
		File home = new File("D:/developer/JavaBlog/MarkdowmImages");
		String[] result = home.list(new FilenameFilter() {
			@Override
			public boolean accept(File dir, String name) {
				if(name.endsWith(".png")) {
					return true;
				}
				else {
					return false;
				}
				
			}
		});
		for(String subFileName : result) {
			System.out.println(subFileName);
		}
	}
}
```

## 遍历子孙文件

```java
public class Client {
	//客户端调用
	public static void main(String[] args) {
		Client client= new Client();
		File home = new File("");
		List<File> result = new ArrayList<>();
		 client.getFiles(home.getAbsolutePath(), result, true);
		for(File subFile : result) {
			System.out.println(subFile);
		}
	}
	
	/**
	 * @Title: getFiles
	 * @Description: 通过递归调用实现遍历子孙文件
	 * @param path 基础路径
	 * @param result 遍历结果集，必须传入一个List<File>，否则递归结果没法保存
	 * @param includeDirectory 结果集是否包含文件夹
	 * @return List<File> 遍历结果集
	 */
	public List<File> getFiles(String path, List<File> result, boolean includeDirectory) {
		if(result==null) {
			result = new ArrayList<>();
		}
		File home = new File(path);
		if(!home.exists()) {
			return  null;
		}
		File[] subFiles = home.listFiles();
		for(File file : subFiles) {
			
			if(file.isDirectory()) {
				if(includeDirectory) {
					result.add(file);
				}
				this.getFiles(file.getAbsolutePath(), result, includeDirectory); //递归遍历
			}
			else {
				result.add(file);
			}
		}
		return result;
	}
}
```

## 过滤子孙文件

```java
public class Client {
	//客户端测试
	public static void main(String[] args) {
		Client client= new Client();
		File home = new File("D:/developer/myBlog/");
		List<File> result = new ArrayList<>();
		client.getFilesWithFilter(home.getAbsolutePath(), result, new MyFilter());
		for(File subFile : result) {
			System.out.println(subFile);
		}
	}
	
	/**
	 * 
	 * @Title: getFilesWithFilter
	 * @Description 该方法保持了过滤器的风格，使用者只需传入过滤器，方法内部会自行对子孙文件夹进行迭代 
	 * @param path 基础路径
	 * @param result 遍历结果集
	 * @param filter 过滤器封装 过滤条件
	 * @return 返回结果集（其实也可以不返回，因为客户端以传入该参数，肯定会持有引用）
	 */
	public List<File> getFilesWithFilter(String path, List<File> result, FilenameFilter filter) {
		if(result==null) {
			result = new ArrayList<>();
		}
		
		File home = new File(path);
		if(!home.exists()) {
			return  null;
		}
		File[] subFiles = home.listFiles();
		for(File subFile : subFiles) {
			if(subFile.isDirectory()) {
				getFilesWithFilter(subFile.getAbsolutePath(), result, filter);
			}
			else {
				if(filter.accept(subFile.getAbsoluteFile().getParentFile(), subFile.getName())) {
					result.add(subFile);
				}
			}
		}
		return result;
	}
}

//过滤器
public class MyFilter implements FilenameFilter{

	@Override
	public boolean accept(File dir, String name) {
		String path = dir.getAbsolutePath()+File.separator+name;
		File subFile = new File(path);
		if(subFile.isDirectory()) {
			subFile.list(this);
		}
		if(name.endsWith(".png")) { //只需要.png文件
			return true;
		}
		return false;
	}
}
```

# 流的分类

（1）输入流和输出流：

* 输入流：只能从中读取数据
* 输出流：只能从中写入数据

（2）字节流和字符流：用法几乎一样，区别在于操作的数据单元不同

* 字节流操作的数据单元是8位的字节（8bit）
* 字符流操作的数据单元是16位的字符

（3）节点流和处理流

* 节点流：可以从/向一个特定的IO设备读/写数据的流，一般都会直连数据源。
* 处理流：也叫做过滤流，用于对一个已存在的流进行连接或封装。这里用到了装饰模式

**使用处理流主要有两方面的优势：1. 有效地提高I/O性能。2. 提供更便捷地操作，一次性处理大批量的I/O内容。因此我们通常都会先创建一个节点流，然后使用处理流包裹住节点流，再对处理流执行IO操作。**

# 输入/输出流的体系（各个I/O类的用途）

## 操作文件

FileInputStream/FileOutputStream用于读/写二进制文件，FileReader和FileWriter用于读取文本文件。他们一般都会结合buffered处理流一起使用。

## 缓冲

涉及4个类：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。主要用来封装其他的节点流以提供缓冲功能。

## 格式化输出

涉及两个类：PrintStream和PrintWriter。两者都是处理流，所以肯定会包裹着一个输出目的地。通过观察他们的构造函数可以看出，我们可以目的地设置为一个节点流、文件、屏幕。`System.out`就是返回一个PrintStream对象，该对象把输出目的地设置为屏幕，因此当调用`System.out.println()`时便可以在屏幕上打印相关信息。

## 操作字节/字符数组

涉及到4个类：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter。他们提供了以I/O的方式进行数组读写的相关方法。使用I/O来操纵字节、字符数组主要有如下优势：

* 这四个类自带Buffer，可以提供缓冲功能
* ByteArrayInputStream具备动态扩展能力，可以动态扩展byte数组，这对于使用传统方式来操纵数组来说是非常困难的。

## 操作字符串

涉及2个类：StringReader、StringWriter。他们都是节点流，只不过流的连接点都是字符串，而不是文件。

**StringReader的作用是读取其内部封装的String，并保存到一个字符数组中。**其内部持有成员变量String。StringReader只有一个构造函数，调用时必须传入一个字符串。

**StringWriter的作用是把字符数组写入到期内部封装的StringBuffer中，接着通过getBuffer()获得StringBuffer，进而可以使用StringBuffer来构建字符串。**

![](http://wx1.sinaimg.cn/mw690/0065Y1avgy1fgu2vem7gfj30hd0a8gr8.jpg)

## 访问管道

涉及4个类：PipeInputStream、PipeOutputStream、PipedReader、PipedWriter。

## 	转换流

涉及2个类：InputStreamReader、InputStreamWriter。**用于把字节流转换为字符流。（注意，I/O体系中并没有提供把字符流转为字节流的转换流，因为没这个必要）**

## 序列化

涉及2个类：ObjectInputStream、ObjectOutputStream。

## 推回输入流

涉及2个类：PushbackInputStream、PushbackReader

## 特殊流

DataInputStream、DataOutputStream

# 流的关闭问题

## 如何关闭含有处理流的节点流

如果节点流被处理流包裹着，那么怎样才算是正确的关闭方式呢？下面提供几种方式：

- 如果你使用JDK7+，可以使用`try-with-resources`语法
- 只需关闭最外层的处理流即可
- 从外到内关闭

## 如何关闭多个节点流

# 流的推荐写法

# 常见案例









# Reference

* 《Java疯狂讲义》
* 《Java编程思想》
* 《Java程序设计语言》
* [Java SE7新特性之try-with-resources语句](http://blog.csdn.net/jackiehff/article/details/17765909)
* [Java的IO操作中关闭流的注意点](http://blog.csdn.net/woshixuye/article/details/23546081)

