# 容器（40）泛型

泛型的最初目的是希望类或方法能够具备最广泛的表达能力。Java通过解耦类方法与所使用的类型之间的约束。泛型的核心概念是：告诉编译器想要使用什么类型，然后编译器帮你处理一切细节。



## 泛型作为元组(tuple)

我们知道，一次方法调用只能有一个返回值，但我们经常需要返回多个对象。一种解决办法是让一个类来持有多个对象，但这样成员变量的类型时写死的，并不方便。更好的解决办法是使用**元组**。元组利用泛型，可以把成员变量定义为通用的泛型，客户端代码传入什么类型，成员变量就是什么类型。我们可以把持有元组的类看作是一个容器，我们往容器中读取成员变量，但无法往其中增加新的对象。**使用元组的好处是，可以再编译期就确保类型安全。**

```java
public class TwoTuple<A, B> {
	public final A first;
	public final B second;
	
	public TwoTuple(A a, B b) {
		first = a;
		second = b;
	}
	
	public String toString() {
		return "first="+first+", second="+second;
	}
	
	public static void main(String[] args) {
		TwoTuple<String, Integer> tt = new TwoTuple<String, Integer>("hello", new Integer(100));
		System.out.println(tt);
	}
}
```

## 泛型用于接口

泛型也可应用于接口，实现**生成器**。可以把生成器看作是工厂方法设计模式的一种应用。

```java
//生成器接口，可以生成各种类型的对象
public interface Generator<T> { //这里必须加T，比如在下一行定义方法返回值时，无法使用T这个关键字
	T next();
}

//父类
public class Coffee {
	private static long counter = 0;
	private final long id = counter++;
	public String toString() {
		return getClass().getSimpleName() + " " + id;
	}
}

//子类
public class Americano extends Coffee {}
public class Breve extends Coffee {}
public class Cappuccino extends Coffee {}
public class Latte extends Coffee {}
public class Mocha extends Coffee {}

//生成器的具体实现
public class CoffeeGenerator implements Generator<Coffee>, Iterable<Coffee>{
	private Class[] types = {Latte.class, Mocha.class, 
			Cappuccino.class, Americano.class, Breve.class};
	private static Random rand = new Random(47);
	
	public CoffeeGenerator() {
	}
	
	private int size = 0;
	public CoffeeGenerator(int sz) {
		size = sz;
	}
	
	@Override
	public Coffee next() {
		try {
			return (Coffee)types[rand.nextInt(types.length)].newInstance();
		} catch (InstantiationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
	
	@Override
	public Iterator<Coffee> iterator() {
		return new CoffeeIterator();
	}
	
	class CoffeeIterator implements Iterator<Coffee> {
		int count = 0;
		@Override
		public boolean hasNext() {
			return count < size;
		}

		@Override
		public Coffee next() {
			count++;
			return CoffeeGenerator.this.next();
		}
		
	}
	
	public static void main(String[] args) {
		CoffeeGenerator gen = new CoffeeGenerator();
		for(int i=0; i<5; i++) {
			System.out.println(gen.next());
		}
		
      //这里构造CoffeeGenerator时，必须传入size作为末端哨兵，来判断何时停止
		for(Coffee c : new CoffeeGenerator(10)) {
			System.out.println(c);
		}
	}
}

```

## 泛型用于方法

泛型也可以应用于方法，包括方法参数和方法返回值。对于方法方法参数化，可以把泛型参数列表置于返回值之前。泛型方法可以置于泛型类或者非泛型类之中。在泛型方法和泛型类之间的选择，如果能用泛型方法，就用泛型方法，因为方法的作用域更窄，更安全。从下面的例子可以看出，泛型支持**自动装箱拆箱。**

```java
public class GenericMethods {
	public <T>void gMethod(T x) {
		System.out.println(x.getClass().getName());
	}
	public static void main(String[] args) {
		GenericMethods gm = new GenericMethods();
		gm.gMethod("");
		gm.gMethod(1);
		gm.gMethod(3L);
		gm.gMethod(1.0);
		gm.gMethod(1.0F);
		gm.gMethod('c');
		gm.gMethod(gm);
	}
}
```

