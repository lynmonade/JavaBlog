# 容易混淆的概念

## generics type 泛型类型

> A generic type is a type with formal type parameter.

在类、接口的签名中，如果涉及泛型，则这个类、接口就是泛型类型的类、接口。注意，它表示的是一个**数据类型**。下例中，Collection<E>和MyClass<T,S>就是generic type。

```java
interface Collection<E> {
	public void add(E x);
  	public Iterator<E> iterator();
}

public class MyClass<T,S> {
	private T t;
  	private S s;
}
```

## type parameter 泛型变量/类型变量/泛型占位符

> A place holder for a type argument.

泛型变量出现在泛型类、泛型接口、泛型方法的签名中。它作为占位符，在客户端具体使用该泛型类、接口、方法时，会传入具体的type argument(类型实参)来替换泛型变量。下例中，E就是泛型变量。

```java
interface Comparable<E> {
  	int compareTo(E other);
}
```

## parameterized type 参数化的泛型类型

> A parameterized type is an instantiation of a generic type with actual type arguments.

参数化的泛型类型表示在客户端代码中，**声明**一个泛型类型(generic type)的变量，并对泛型变量(type parameter)赋予具体的类型实参(type argument)。

在下例中，Collection<String>表示参数化的泛型类型。注意，参数化的泛型类型只涉及变量声明，不涉及变量的new初始化，因此变量col的参数化泛型类型是Collection<String>，而不是LinkedList<String>。

```java
Collection<String> col = new LinkedList<String>();
```

具体来说，会在下列三个地方使用到参数化的泛型类型：

1. 声明成员变量时
2. 声明方法形参时
3. 声明局部变量时

```java
public class Box<E> {
	private Comparable<E> com; //声明成员变量
	
	//Collection<? extends T> col 声明方法形参
	//注意，void前面的<T>并不是parameterized type的声明，而是generic method的声明
	public static <T> void m1(Collection<? extends T> col) {
		List<? extends Number> list; //声明局部变量 
	}
}
```

### concrete parameterized type 具体式的参数化泛型类型

> An instantiation of a generic type where all type arguments are concrete types rather than wildcards.

它表示在声明参数化的泛型类型时，类型实参是**"具体的类"**，而不涉及任何通配符表达式。下例中Collection<String>就符合，而Collection<?>, Collection<? extends Number>, 就不符合。

```java
Collection<String> list = new ArrayList<String>(); //concrete parameterized type
Collection<?> list2 = new ArrayList<String>(); // NOT concrete parameterized type
Collection<? extends Number> list3 = new ArrayList<Integer>(); //NOT concrete parameterized type
```

### wildcard parameterized type

> An instantiation of a generic type where the type argument is a wildcard (as opposed to a concrete type).

它表示在声明参数化的泛型类型时，类型实参是**"通配符表达式"**。下例中，Collection<?>, Collection<? extends Number>符合，而Collection<String>不符合。

```java
Collection<String> list = new ArrayList<String>(); //concrete parameterized type
Collection<?> list2 = new ArrayList<String>(); // wildcard parameterized type
Collection<? extends Number> list3 = new ArrayList<Integer>(); //wildcard parameterized type
```

wildcard parameterized type不能用于new创建对象，可以把它理解为接口，我们只能用接口来引用实例，但不能创建接口对象。

## type argument 类型实参

> A reference type that is used for the instantiation of a generic type or for the instantiation of a generic method, or a wildcard that is used for the instantiation of a generic type .  An actual type argument replaces the formal type parameter used in the declaration of the generic type or method.

参数实参是参数化泛型类型(parameterized type)的尖括号中的值，类型实参用于替换泛型类型(generic type)中的泛型变量(type parameter)。

类型实参也只涉及变量声明，不涉及变量的new初始化。所以在下例中，等号左边的Number, ?, ? extends Number, Comparable<String>都是类型实参。类型实参可以是：

1. 对象类型，比如Number
2. 通配符，比如?
3. 带边界的通配符：比如? extends Number
4. 参数化的泛型类型：比如Comparable<String>

```java
List<Number> list = new ArrayList<Number>();
List<?> list2 = new ArrayList<String>();
List<? extends Number> list3 = new ArrayList<Integer>();
List<Comparable<String>> list4 = new ArrayList<Comparable<String>>();
```

### wildcard 通配符

> A syntactic construct that denotes a family of types.Wildcards are used to declare so-called wildcard parameterized types, where a wildcard is used as an argument for instantiation of generic types. Wildcards are useful in situations where no or only partial knowledge about the type argument of a parameterized type is required.

wildcard翻译过来就是通配符。它只能用于type argument所在的地方，而type argument又用于parameterized type，因此通配符只能应用于声明成员变量、声明方法形参、声明局部变量，不能用于声明泛型接口、泛型类、泛型方法。

## bound 边界
boud可与type parameter一起使用，形成带边界的泛型变量。
### bounded type parameter

### bounded wildcard
 
# FAQ

## 数组与泛型
## 


# 烧脑问题

# Reference

#  